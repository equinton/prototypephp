\chapter{ObjetBDD - accéder aux bases de données}\label{objetbdd}

\section{Présentation}

ObjetBDD est une classe qui sert d'interface entre l'application et la base de données. Elle a été créée pour simplifier les requêtes, seules celles d'interrogation spécifiques devront être écrites.

Historiquement, ObjetBDD travaillait avec ADODB, une classe qui encapsulait la connexion à la base de données. Avec la sortie de PDO, la classe a été adaptée pour utiliser des connexions PDO.
Elle était également prévue pour fonctionner initialement avec Sybase ASE et MySQL. Les récentes évolutions ont porté sur le support des bases PostgreSQL : il n'est pas certain que toutes les fonctionnalités soient disponibles pour MySQL ou Sybase ASE.

Les fonctions initiales ont été modifiées ou complétées pour supporter maintenant les requêtes préparées.

\section{Fonctionnalités générales}
\subsection{Formatage des dates}
Les dates stockées dans les bases de données sont dans un format difficilement utilisable. La classe transforme automatiquement les dates dans le format français par défaut (mais d'autres formats possibles). 

Elle est également capable de transformer les dates reçues du navigateur au format de stockage. Le format de saisie est libre : la plupart des séparateurs sont supportés, l'année est rajoutée automatiquement, etc.

Le formatage des date inclut également les dates/heures.

\subsection{Opérations d'écriture en base de données}

La classe dispose de deux fonctions pour écrire les informations : ecrire() et supprimer(). La fonction ecrire() va décider s'il faut réaliser un insert ou un update, en fonction de la clé fournie. Par convention, si la clé vaut 0, un insert sera réalisé.

\subsection{Gestion des erreurs}

En cas d'échec d'exécution d'une requête SQL, la classe génère une exception.

\section{Variables générales utilisables}

Ces variables sont toutes publiques.
\begin{longtable}{|p{3cm}|c|p{8.5cm}|}
\hline
\textbf{Variable} & \textbf{Type} & \textbf{Signification} \\
\hline
\endhead
connection & PDO & instance PDO. Peut être utilisée pour instancier une nouvelle classe basée sur ObjetBDD à l'intérieur d'une fonction \\
\hline
id\_auto & entier & Si à 1, la classe gère la création automatique des identifiants. Si à 2, l'identifiant est généré manuellement, avec une requête de type \textit{max(id)} \\
\hline
formatDate & entier & 0 : amj, 1 : jma (défaut), 2 : mja \\
\hline
debug\_mode & entier & 0 : pas de mode de débogage, 1 : affichage des messages d'erreur, 2 : affichage de toutes les commandes SQL générées
\\
\hline
error\_data & tableau & liste de toutes les erreurs détectées lors de la vérification des données.  \\
 & & \$errorData[]["code"] : code d'erreur : \\
	& & 0 : non précisé \\
	& & 1 : champ non numérique \\
	& & 2 : champ texte trop grand \\
	& & 3 : masque (pattern) non conforme \\
	& & 4 : champ obligatoire vide \\
	& & \$errorData[]["colonne"] : champ concerne \\
	& & \$errorData[]["valeur"] : valeur initiale \\
\hline
srid & numérique & Valeur du srid pour les variables de type Postgis \\
\hline
quoteIdentifier & caractère & caractère utilisé pour encadrer les noms des colonnes dans les requêtes (pour les colonnes contenant une majuscule ou un accent) \\
\hline
transformComma & entier & Si à 1 (défaut), les virgules sont transformées en points pour les nombres décimaux \\
\hline

\caption{Liste des variables utilisables dans ObjetBDD}

\end{longtable}

En principe, les variables sont initialisées lors de l'instanciation de la classe, mais peuvent être modifiées à la volée, si nécessaire.

La classe est conçue pour fonctionner en UTF8.

\section{Héritage}

La classe ObjetBDD n'est pas instanciable, et doit donc être héritée. En particulier, le constructeur de la classe doit être surchargé pour rendre la classe opérante. 

\section{Fonctions principales}
\subsection{Constructeur de la classe}

\begin{lstlisting}
function __construct(PDO &$p_connection, array $param = array())
\end{lstlisting}
\subsubsection{Paramètres}
La fonction doit recevoir une instance PDO, correspondant à une connexion déjà réalisée à la base de données. Cette instance PDO est stockée ensuite dans la variable \textit{connection}, qui peut être réutilisée si d'autres classes héritées sont à instancier à l'intérieur du code.

Le tableau \textit{param} comprend, si nécessaire, l'ensemble des variables globales à mettre à jour.

\subsubsection{Surcharge}

Le constructeur doit être impérativement être surchargé, avec le code minimal suivant (exemple) : 

\begin{lstlisting}
function __construct($bdd, $param = array()) {
		$this->table = "acllogin";
		$this->colonnes = array (
				"acllogin_id" => array (
						"type" => 1,
						"key" => 1,
						"requis" => 1,
						"defaultValue" => 0 
				),
				"login" => array (
						"requis" => 1 
				),
				"logindetail" => array (
						"type" => 0,
						"requis" => 1 
				) 
		);
		parent::__construct ( $bdd, $param );
	}
\end{lstlisting}

\textit{table} doit correspondre au nom de la table (sans tenir compte du schéma, traité lors de la connexion à la base de données).

\textit{colonnes} contient la description des colonnes de la table. Chaque colonne doit être nommée, et contient un tableau, dont les  attributs possibles sont les suivants :

\begin{longtable}{|p{3cm}|p{10cm}|}
\hline
\textbf{Variable} & \textbf{Signification} \\
\hline
\endhead
type & 0 : varchar \\
& 1 : numérique (y compris décimaux) \\
& 2 : date \\
& 3 : datetime \\
& 4 : champ Postgis \\
\hline
requis & Si à 1, le contenu doit être fourni pour réaliser l'écriture \\
\hline
key & Si à 1, l'attribut est utilisé comme clé primaire (en principe, n'utiliser que des clés mono-attributs, même si la classe devrait être capable de gérer des clés multiples) \\
\hline
defaultValue & valeur par défaut. Il est possible d'indiquer le nom d'une fonction (entre guillemets). Parmi celles-ci, il est possible d'utiliser :\\
& getDateJour : retourne la date du jour \\
& getDateHeure : retourne la date et l'heure courante \\
& getLogin : retourne la valeur de la variable \$\_SESSION["login"]\\
\hline
parentAttrib & si vaut 1, la valeur est utilisée comme clé étrangère principale de l'enregistrement \\
\hline
longueur & pour les champs de type varchar, indique la longueur maximale autorisée (attention au codage UTF-8, les caractères accentués étant comptés pour 2) \\
\hline
pattern & pattern traité par expression régulière, pour tester la correspondance de l'information fournie au modèle décrit \\
\hline

\caption{Liste des attributs permettant de décrire les colonnes de la table}

\end{longtable}

Les deux derniers attributs sont toujours utilisables, mais en rarement employés.

\subsection{lire}
\begin{lstlisting}
lire($id, $getDefault = true, $parentValue = 0)
\end{lstlisting}

Fonction permettant de récupérer un enregistrement. Elle accepte les paramètres suivants :
\begin{longtable}{|p{3cm}|p{10cm}|}
\hline
\textbf{Variable} & \textbf{Signification} \\
\hline
\endhead
id & clé de l'enregistrement \\
\hline
getDefault & si à \textit{true}, récupère les valeurs par défaut si l'enregistrement n'existe pas dans la base (initialisation d'une saisie, par exemple)\\
\hline
parentValue & clé de l'enregistrement parent. Si \textit{getDefault} vaut \textit{true}, pré-remplit l'attribut qui contient la valeur \textit{parentAttrib} avec la clé fournie dans \textit{parentValue} \\
\hline

\caption{Liste des paramètres de la fonction lire}
\end{longtable}

La fonction retourne le tableau associatif correspondant.

\subsection{ecrire}
\begin{lstlisting}
ecrire($data)
\end{lstlisting}
Déclenche l'écriture des informations dans la base de données. \$data doit être un tableau qui comprend les attributs à écrire (au minimum, les attributs déclarés comme obligatoires).

Le nom des attributs fournis doit correspondre exactement au nom des colonnes.

En principe, ce tableau correspond à la variable \$\_REQUEST.

La fonction génère soit une commande insert, soit une commande update. En principe, la commande insert est générée si la clé fournie vaut 0.

Elle retourne la clé modifiée ou créée.

\subsection{supprimer}

\begin{lstlisting}
supprimer($id)
\end{lstlisting}

Permet de supprimer un enregistrement, à partir de sa clé. Attention : la fonction ne gère pas les suppressions en cascade, si ce n'est pas prévu directement dans la base de données.

\subsection{supprimerChamp}

\begin{lstlisting}
supprimerChamp($id, $champ)
\end{lstlisting}

Fonction très pratique pour supprimer tous les enregistrements fils. Elle génère une requête du type :
\begin{lstlisting}
delete from table where :champ = :id;
\end{lstlisting}


\subsection{getListe}

\begin{lstlisting}
getListe($order = "")
\end{lstlisting}

Fonction récupérant l'ensemble des enregistrements d'une table, triés ou non selon le contenu de la variable \$order.

\subsection{getListFromParent}

\begin{lstlisting}
function getListFromParent($parentId, $order = "")
\end{lstlisting}

Retourne la liste des enregistrements fils correspondant à la clé étrangère \$parentId. Le résultat peut ou non être trié selon les paramètres définis dans la seconde variable.

\subsection{getListParamAsPrepared}

\begin{lstlisting}
function getListeParamAsPrepared($sql, $data)
\end{lstlisting}

Permet de récupérer une liste d'enregistrements à partir de la requête SQL fournie et du tableau des données à insérer (requêtes préparées PDO).

\subsection{ecrireTableNN}

\begin{lstlisting}
ecrireTableNN($nomTable, $nomCle1, $nomCle2, $id, $lignes)
\end{lstlisting}

Fonction permettant de mettre à jour les tables de relation NN, selon le schéma suivant :

\begin{figure}[H]
\centering
\includegraphics[width=0.8\linewidth]{dessin/schema-nn}
\caption{Structure d'une liaison N-N}
\end{figure}

En général, la saisie de ce type de liaisons est effectuée par des cases à cocher, ce qui permet de récupérer un tableau contenant la liste des clés de la table2 (champs html \textit{<input type checkbox name="attribut[]">}).

Les arguments à indiquer sont les suivants :
\begin{longtable}{|p{3cm}|p{10cm}|}
\hline
\textbf{Variable} & \textbf{Signification} \\
\hline
\endhead
nomTable & Nom de la table NN (table\_nn dans notre exemple) \\
\hline
nomCle1 & nom de l'attribut contenant la clé de la table principale \\
\hline
nomCle2 & nom de l'attribut contenant les clés de la table secondaire \\
\hline
id & valeur de la clé de la table principale \\
\hline
lignes & tableau contenant les valeurs de la table secondaire à conserver ou à rajouter \\
\hline

\caption{Liste des paramètres de la fonction ecrireTableNN}
\end{longtable}

La fonction ne génère que les requêtes de modification nécessaires (insertion ou suppression). Elle permet d'éviter de déclarer une instanciation d'ObjetBDD pour la table\_nn.

\subsection{getBlobReference}

\begin{lstlisting}
function getBlobReference($id, $fieldName)
\end{lstlisting}

Fonction permettant de récupérer un champ binaire stocké dans la base de données. PDO retourne l'identifiant interne PHP du fichier temporaire contenant l'information binaire lu.

Arguments :
\begin{longtable}{|p{3cm}|p{10cm}|}
\hline
\textbf{Variable} & \textbf{Signification} \\
\hline
\endhead
id & Clé de l'enregistrement \\
\hline
fieldName & nom de la colonne contenant l'information binaire \\
\hline
\caption{Liste des paramètres de la fonction getBlobReference}
\end{longtable}

\subsection{encodeData}

\begin{lstlisting}
encodeData($data)
\end{lstlisting}

Fonction encodant les quottes comprises dans les champs du tableau data, pour toutes les requêtes SQL directes (exécution ne passant pas par le mécanisme des requêtes préparées).

\subsection{executeAsPrepared}

\begin{lstlisting}
function executeAsPrepared($sql, $data, $onlyExecute = false) 
\end{lstlisting}

Fonction exécutant la requête fournie sous forme de requête préparée. Les variables à insérer sont décrites dans le tableau \textit{data}. Si l'attribut \$onlyExecute vaut true, la fonction ne retourne pas de résultat.

\subsection{executeSQL}

\begin{lstlisting}
function executeSQL($ls_sql) {
\end{lstlisting}

Exécute la commande SQL, sans précaution particulière (attention aux risques d'injection).

\subsection{formatDateDBversLocal}

\begin{lstlisting}
function formatDateDBversLocal($date, $type = 2)
\end{lstlisting}

Transforme la date, au format de la base de données, vers le format lisible pour l'utilisateur.

Si \$type vaut 3, la fonction retourne le champ au format date/heure.

\subsection{formatDateLocaleVersDB}
\begin{lstlisting}
function formatDateLocaleVersDB($date, $type = 2)
\end{lstlisting}

Transforme la date fournie en format géré par la base de données. Si le type vaut 3, un champ de type date/heure est attendu.

\subsection{utilDatesDBVersLocale}
\begin{lstlisting}
function utilDatesDBVersLocale($data)
\end{lstlisting}

Transforme les dates présentes dans le tableau joint à un format lisible par l'utilisateur.

\begin{lstlisting}
function utilDatesLocaleVersDB($data)
\end{lstlisting}

Transforme les dates présentes dans le tableau joint au format supporté par la base de données.

\section{Utilisation avancée}
\subsection{Requête multi-table contenant des champs date}


\chapter{Décrire les actions}